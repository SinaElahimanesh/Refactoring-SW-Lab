# گزارش آزمایش چهارم درس آزمایشگاه مهندسی نرم‌افزار (بازآرایی کد)

## گزارش

### بازآرایی Facade (دو مورد)
برای این بازآرایی دو کلاس CodeGenerator و ٍLexialAnalyzer را مورد بازآرایی قرار دادیم و دور آنها Facade کشیدیم. به این ترتیب که دسترسی به آنها از طریق فسادشان امکان‌پذیر شده است. همچنین باید تمامی متدهایی که برای دسترسی به آنها لازم است را هم به فسادشان منتقل کنیم. به این ترتیب در تصاویر زیر داریم:
<img width="889" alt="Screenshot 1402-05-21 at 12 04 53 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/f9380814-6c79-4f10-a29e-b98007650eec">

<img width="789" alt="Screenshot 1402-05-21 at 12 05 11 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/3cb58107-e52e-4af5-a9f3-c23c5163765d">

همچنین پس از آن باید Find Usages را بزنیم و هرجایی که از آن استفاده شده است را هم تغییر دهیم. به این ترتیب که به جای دسترسی مستقیم از فساد به آن دسترسی داشته باشیم.
<img width="1014" alt="Screenshot 1402-05-21 at 12 08 47 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/68ac059e-2bae-4b3c-aa38-5b21ce423e9e">


## بازآرایی استفاده از Polymorphism به جای شرط
در این بازآرایی کلاس Action را به یک ابسترکت کلاس تبدیل می‌کنیم و سپس فیلد اکشن را از آن حذف می‌کنیم و فقط getAction می‌زنیم. سپس سه کلاس می‌زنیم که از آن extend می‌کنند. هریک از این کلاس‌ها از پلیمورفیسم استفاده می‌کنیم و ان استرینگ‌ها را override می‌کنیم.
<img width="540" alt="Screenshot 1402-05-21 at 12 19 58 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/902acfd5-c63c-490e-a904-76ae9ff844ac">

<img width="496" alt="Screenshot 1402-05-21 at 12 20 11 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/5b5b53d6-fc80-40be-9615-4a1a7e5fcdf3">

<img width="540" alt="Screenshot 1402-05-21 at 12 20 23 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/2ebe9c87-3ffc-4c4e-a192-46193a356639">

<img width="605" alt="Screenshot 1402-05-21 at 12 20 35 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/c58e9eef-4e26-405a-aadc-f143fcba6030">

سپس هرجایی از آن استفاده شده درست می‌کنیم.

<img width="1049" alt="Screenshot 1402-05-21 at 12 23 36 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/7bb0c15e-2913-4a3c-a7bf-7cd0593d6af4">

به عنوان نمونه از getAction که برای action تعریف کرده بودیم و آن را اورراید کرده بودیم در این شروط استفاده می‌کنیم.

<img width="1045" alt="Screenshot 1402-05-21 at 12 24 26 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/6be5dc3a-4a3f-4b53-9b70-f388cdc490d6">


 ## بازآرایی Separate Query From Modifier
 این بازآرایی را در کلاس Memory روی تابع getTemp انجام داده‌ایم. همچنین روی توابع دیگر این کلاس نظیر getDateAddress هم این کار ممکن است. به این ترتیب که تغییرات را از گرفتن مقدار جدا کرده‌ایم و دو تابع جدا کرده‌ایم.
 
 <img width="626" alt="Screenshot 1402-05-21 at 12 32 46 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/4d5a5223-b960-4063-8fee-0049413e252e">


سپس در جاهایی که از آن استفاده شده است هر دو تابع را صدا می‌زنیم.
<img width="789" alt="Screenshot 1402-05-21 at 12 33 22 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/a99e290e-a682-4110-8efb-d1f70c4126aa">

<img width="822" alt="Screenshot 1402-05-21 at 12 33 37 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/191896d6-4799-4df6-8e19-4363f8879356">

<img width="792" alt="Screenshot 1402-05-21 at 12 33 49 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/edc9c756-ec84-4c9a-8d4c-bead58533b17">

<img width="744" alt="Screenshot 1402-05-21 at 12 34 01 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/b7de183b-8ee3-4120-991e-1cfbd7bc5070">


## بازآرایی های دیگر (Separate Query From Modifier)

در اینجا در Memory تابع saveMemory را هم مانند قسمت قبل گرفتن مقدار و تغییرات را از هم جدا می‌کنیم. در نتیجه می‌توان به صورت در هرجایی که تابع اول صدا زده می‌شود تابع دوم را هم صدا زد.

<img width="640" alt="Screenshot 1402-05-21 at 12 36 05 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/e5a34ab9-41c4-44ee-b96c-1b6ca758a7cb">

در نتیجه باید تغییرات را در کاربرد آن هم اعمال کنیم.

<img width="683" alt="Screenshot 1402-05-21 at 12 37 07 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/83202504-c8bf-4578-8d17-df209e9c6ceb">

<img width="1027" alt="Screenshot 1402-05-21 at 12 37 18 PM" src="https://github.com/SinaElahimanesh/Refactoring-SW-Lab/assets/59636948/4f52bbef-325b-49be-9c00-99d40e7e49c2">

## بازآرایی‌های دیگر 



## پرسش‌ها

۱-

- کد تمیز (Clean Code): به کدی گفته می‌شود که تمیز، قابل فهم و قابل نگهداری باشد. اگر در نوشتن کدی می‌خواهیم تمیزی کد را رعایت کنیم همواره این را در ذهنمان باید داشته باشیم که قرار است این کد توسط افراد دیگر خوانده شود و درک شود و تغییر داده شود. شاید در نگهداری آن هم افراد دیگری دخیل باشند. بنابراین باید سعی کنیم کدی قابل فهم و قابل تغییر با انعطاف‌پذیری بالا بنویسیم.

- بدهی فنی (Technical Debt): برخی از موارد فنی در کد هستند که ممکن است عدم فیکس آنها در آینده هزینه‌های اضافی بهمان تحمیل کند. در نتیجه باید آنها را در جایی بنویسیم و در اولین فرصت این بدهی‌ها را پرداخت کنیم و آنها را پیاده نماییم. به این نکته باید توجه کنیم که هرچقدر زمان بیشتری از یک بدهی فنی بگذرد امکان اینکه خطای بزرگتری در کد ایجاد کند بیشتر می‌شود.

- بوی بد (Bad Smell): این نوع از موارد خطای فنی نیستند و این‌گونه نیست که باعث ایجاد خطا در اجرای کد شود و کارایی را از بین ببرند ولی نوعی از ضعف‌ها در طراحی هستند که می‌توانند ریسک انواع باگ‌ها را بالا ببرند و یا سرعت طراحی را کاهش دهند و در نتیجه در بلندمدت ایجاد مشکل نمایند.

۲- دسته‌ی اول (Bloaters): این دسته مواردی را شامل می‌شود که به دلیل حجم زیاد و بزرگ بودن ایجاد مشکل می‌کنند. به عنوان نمونه متدهای طولانی، کلاس‌های بزرگ و لیست پارامترهای طولانی در این دسته قرار می‌گیرند. به این ترتیب در این دسته طولانی بودن و حجم زیاد می‌تواند باعث ایجاد خطا و مشکلاتی در نگهداری کد شود.

دسته دوم (Object-Orientation Abusers): این دسته به مواردی اشاره دارد که سو استفاده از شی‌گرایی در جای نادرست است. مثلا اینکه دو کلاس با کارایی یکسان ولی نام‌های متفاوت داشته باشیم و یا اینکه به صورت نابه‌جایی فیلدهای موقتی داشته باشیم و یا استفاده از switch statement نوع دیگری از این موارد سو استفاده است. به عبارتی این موارد کاربردهای ناقص یا نادرست از شی‌گرایی هستند.

دسته سوم (Change Preventers): این دسته از بوهای بد به تغییرات مرتبط می‌شوند. به صورتی که برای ایجاد تغییر در یک قسمت از کد ناچار به این هستیم که قسمت‌های زیادی از کد را در جاهای مختلف تغییر دهیم. به این ترتیب تغییرات پیچیده و طولانی می‌شوند. به عنوان نمونه بوی بد shotgun surgery دقیقا نمونه‌ی همین مورد است که ساچمه‌ها به جاهای دیگر کد میریزند و نیازمند تغییر همه‌ی کد هستیم.

دسته‌ی چهارم (Dispensables): این بوی بد اشاره به موارد اضافی دارد که شاید حذف کردن آنها باعث شود که کد تمیزتر و بهتری داشته باشیم. کامنت‌های اضافی، کدهای داپلیکیت و کدهای مرده که قابل دسترسی نیستند از این موارد اضافه هستند که کد را به صورت اضافی طولانی و پیچیده کرده‌اند و حذف‌ کردن آنها بهتر است.

دسته‌ی پنجم (Couplers): این دسته مواردی هستند که کاپلینگ بین کلاس‌ها را زیاد کرده‌اند و این افزایش وابستگی بین کلاس‌ها می‌تواند باعث ایجاد مشکلات مختلفی شود. به عنوان نمونه زنجیره‌ی پیام‌ها (message chains) یکی از این موارد هستند که باعث افزایش کاپلینگ می‌شوند. در این دسته همینطور کال کردن متعدد کلاس‌ها توسط همدیگر در یک زنجیره را داریم و باعث افزایش کاپلینگ می‌شود. موارد دیگر این دسته هم پترن مشابهی در افزایش کاپلینگ دارند.

۳- الف) این نوع از انواع بوی بد در دسته بندی Dispensables (موارد بی‌مصرف) قرار دارد. چراکه به این معنی است که اگر کلاسی در مواقع بسیار نادری استفاده می‌شود و آنقدر کاربردی نیست یا توجه ما را به خود جلب نمی‌کند، باید حذف شود. چونکه نگهداری یک کلاس هزینه‌بر است و ممکن است در آینده ایجاد مشکل کند.

۳- ب) برای برطرف کردن این بوی بد دو راهکار داریم. یکی اینکه برای کامپوننت‌هایی که نزدیک به بی‌فایده‌ بودن هستند از inline classes استفاده کنیم. یعنی می‌توان هر فیچری که این کلاس دارد را به کلاس دیگری که آن را در بر می‌گیرد منتقل نمود.

راهکار دیگر هم این است که از برای زیرکلاس‌ها با تعداد توابع کم می‌توان از collapse hierarchy استفاده نمود. بدین معنی که زیرکلاس را با سوپرکلاس با هم ترکیب نماییم و یک کلاس ایجاد کنیم.

۳- پ) گاهی اوقات یک کلاس که به ظاهر تنبل می‌آید در واقع برای توسعه‌های آینده ایجاد شده است و ممکن است در آینده به کار بیاید. در این مورد باید سعی کنیم خودمان به یک تعادل نسبی بین سادگی و همچنین تمیز بودن و خوانایی کد برقرار نماییم.
